import { app, BrowserViewConstructorOptions, BrowserWindow, ipcMain, shell } from 'electron'
import path from 'path'
import { outputJSON, outputJSONSync, readJSON, createWriteStream } from 'fs-extra'
import request from 'request'

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

import { setApplicationMenu } from './application_menu'
import Icon from './static/icon.png'
import { getSongs } from './scraper';

let appWindow: BrowserWindow = null

const CONFIG_PATH = path.join(
  app.getPath('userData'),
  'window.json'
)

const gotTheLock = app.requestSingleInstanceLock()

if (!gotTheLock) {
  app.quit()
} else {
  app.on('second-instance', () => {
    if (appWindow) {
      if (appWindow.isMinimized()) appWindow.restore()
      appWindow.focus()
    }
  })

  if (process.platform === 'linux') {
    app.disableHardwareAcceleration()
  }

  app.on('ready', () => {
    const defaultWindowOpts = {
      minWidth: 800,
      minHeight: 600,
      center: true,
      show: false,
      autoHideMenuBar: true,
      icon: Icon,
      webPreferences: {
        // FIXME: this may be unnecessary
        webSecurity: false,
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      }
    }

    readJSON(CONFIG_PATH, (_, savedWindowOpts: BrowserViewConstructorOptions | undefined) => {
      appWindow = new BrowserWindow({
        ...defaultWindowOpts,
        ...savedWindowOpts
      })

      setApplicationMenu(appWindow)

      appWindow.once('ready-to-show', () => appWindow.show())

      appWindow.on('close', () => {
        const [ width, height ] = appWindow.getSize()
        const [ x, y ] = appWindow.getPosition()
        outputJSON(CONFIG_PATH, {
          width,
          height,
          x,
          y
        }).catch(err => console.error(err))
        app.quit()
      })

      const STORE_PATH = path.join(
        app.getPath('userData'),
        'store.json'
      )

      ipcMain.handle('read-store', async () => {
        try {
          return await readJSON(STORE_PATH)
        } catch (err) {
          if (err.code === 'ENOENT') return {}
          throw err
        }
      })

      ipcMain.handle('write-store', (_event, data) => {
        outputJSONSync(STORE_PATH, data)
      })

      ipcMain.handle('get-name', () => app.getName())

      ipcMain.handle('download-file', (_event, fileUrl: string) => {
        const filename = decodeURIComponent(fileUrl.split('/').pop())
        const downloadPath = path.join(app.getPath('downloads'), filename)
        const stream = createWriteStream(downloadPath)
        request(fileUrl).pipe(stream).on('finish', () => {
          shell.openPath(downloadPath)
        })
      })

      ipcMain.handle('scrape', async (_event, creds: { username: string, password: string }) => {
        return await getSongs(appWindow, creds)
      })

      appWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)
    })
  })
}
